import { existsSync, mkdirSync, readdirSync, writeFileSync } from "node:fs";
import { dirname, join, resolve } from "node:path";

import { siteBuilder } from "~/sst/aws/helpers/site-builder";
import { DEFAULT_ACCOUNT_ID } from "~/sst/cloudflare";
import { WorkerUrl } from "~/sst/cloudflare/providers/worker-url";
import { ZoneLookup } from "~/sst/cloudflare/providers/zone-lookup";
import { VisibleError } from "~/sst/error";
import { Link } from "~/sst/link";
import { PhysicalName } from "../physical-name";

export interface TanstackStartArgs {
  path: $util.Input<string>;
  entrypoint: $util.Input<string>;
  url?: $util.Input<boolean>;
  domain?: $util.Input<string>;
  environment?: $util.Input<Record<string, $util.Input<string>>>;
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  link?: $util.Input<any[]>;
}

export class TanstackStart
  extends $util.ComponentResource
  implements Link.Linkable
{
  static readonly __pulumiType = "pd:cloudflare:TanstackStart";

  private _worker: cloudflare.Worker;
  private _url: WorkerUrl;
  private _version?: cloudflare.WorkerVersion;
  private _deployment?: cloudflare.WorkersDeployment;
  private _domain?: cloudflare.WorkersCustomDomain;

  constructor(
    name: string,
    args: TanstackStartArgs,
    opts?: $util.ComponentResourceOptions,
  ) {
    super(TanstackStart.__pulumiType, name, args, opts);

    const path = $util.output(args.path).apply((path) => {
      if (!existsSync(path))
        throw new VisibleError(`No project found at "${resolve(path)}".`);

      return path;
    });

    const environment = $util
      .all([
        $util.output(args.environment),
        $jsonStringify({
          name: $app.name,
          stage: $app.stage,
        }),
      ])
      .apply(([env, app]) => ({ ...env, SST_RESOURCE_App: app }));

    $util.all([path, environment]).apply(([path, environment]) => {
      const sstPath = resolve(join(path, "src", "sst-env.d.ts"));

      mkdirSync(dirname(sstPath), { recursive: true });
      writeFileSync(
        sstPath,
        `/* This file is auto-generated by SST. Do not edit. */
/* eslint-disable */

/// <reference types="vite/client" />
interface ImportMetaEnv {
${Object.keys(environment)
  .map((key) => `  readonly ${key}: string`)
  .join("\n")}
}
interface ImportMeta {
  readonly env: ImportMetaEnv
}`,
      );
    });

    const secrets = $output(args.link)
      .apply((linkables) => linkables?.filter(Link.isLinkable) ?? [])
      .apply((linkables) =>
        $util.all(
          linkables.map(
            (linkable) =>
              [
                linkable.urn.apply(
                  (urn) => `SST_RESOURCE_${urn.split("::").at(-1)!}`,
                ),
                $jsonStringify(linkable.getSSTLink().properties),
              ] as const,
          ),
        ),
      )
      .apply((entries) => Object.fromEntries(entries));

    const workerName = new PhysicalName(
      `${name}Worker`,
      { max: 64 },
      { parent: this },
    ).result.apply((name) => name.toLowerCase());

    const compatibilityDate = new Date().toISOString().slice(0, 10);
    const compatibilityFlags = ["nodejs_compat"];

    $util
      .all([
        path,
        $jsonStringify(
          {
            $schema: "node_modules/wrangler/config-schema.json",
            name: workerName,
            compatibility_date: compatibilityDate,
            compatibility_flags: compatibilityFlags,
            main: args.entrypoint,
            vars: environment,
          },
          undefined,
          2,
        ),
        secrets.apply((secrets) =>
          Object.entries(secrets)
            .map(([key, value]) => `${key}='${value}'`)
            .join("\n"),
        ),
      ])
      .apply(([path, config, secrets]) => {
        const wranglerPath = resolve(join(path, "wrangler.jsonc"));
        mkdirSync(dirname(wranglerPath), { recursive: true });
        writeFileSync(wranglerPath, config);

        const secretsPath = resolve(join(path, ".dev.vars"));
        mkdirSync(dirname(secretsPath), { recursive: true });
        writeFileSync(secretsPath, secrets);

        const typegen = "bun run wrangler types";
        siteBuilder(
          `${name}CloudflareTypes`,
          {
            create: typegen,
            update: typegen,
            dir: join($cli.paths.root, path),
            environment,
            triggers: [config, secrets],
          },
          { parent: this },
        );
      });

    this._worker = new cloudflare.Worker(
      `${name}Worker`,
      {
        accountId: DEFAULT_ACCOUNT_ID,
        name: workerName,
        tags: [$app.name, $app.stage],
      },
      { parent: this },
    );

    this._url = new WorkerUrl(
      `${name}WorkerUrl`,
      {
        accountId: DEFAULT_ACCOUNT_ID,
        scriptName: this._worker.name,
        enabled: $output(args.url).apply((url) => url ?? false),
      },
      { parent: this },
    );

    if ($dev) {
      this.registerOutputs({
        _metadata: {
          mode: "placeholder",
          path,
          environment,
        },
        _dev: {
          environment,
          command: "bun run dev",
          autostart: true,
          directory: path,
        },
      });

      return;
    }

    const build = "bun run build";
    const dist = $util
      .all([
        path,
        siteBuilder(
          `${name}Builder`,
          {
            create: build,
            update: build,
            dir: path.apply((path) => join($cli.paths.root, path)),
            environment,
            triggers: [Date.now()],
          },
          { parent: this },
        ),
      ])
      .apply(([path]) => {
        const distPath = join(path, "dist");
        if (!existsSync(distPath))
          throw new VisibleError(
            `No build output found at "${resolve(distPath)}".`,
          );

        return distPath;
      });

    this._version = new cloudflare.WorkerVersion(
      `${name}WorkerVersion`,
      {
        accountId: DEFAULT_ACCOUNT_ID,
        workerId: this._worker.id,
        compatibilityDate,
        compatibilityFlags,
        bindings: $util
          .all([environment, secrets])
          .apply(([environment, secrets]) => [
            ...Object.entries(environment).map(([name, text]) => ({
              type: "plain_text",
              name,
              text,
            })),
            ...Object.entries(secrets).map(([name, text]) => ({
              type: "secret_text",
              name,
              text,
            })),
          ]),
        assets: {
          directory: dist.apply((dist) =>
            join($cli.paths.root, dist, "client"),
          ),
        },
        mainModule: "index.js",
        modules: dist.apply((dist) =>
          readdirSync(join(dist, "server", "assets"))
            .filter(
              (name) =>
                (name
                  .split(".")
                  .at(-1)
                  ?.match("^(js|txt|html|sql|bin|wasm)$") ?? null) !== null,
            )
            .map((name) => ({
              name: join("assets", name),
              contentType: "application/javascript+module",
              contentFile: resolve(join(dist, "server", "assets", name)),
            }))
            .concat({
              name: "index.js",
              contentType: "application/javascript+module",
              contentFile: resolve(join(dist, "server", "index.js")),
            }),
        ),
      },
      { parent: this },
    );

    this._deployment = new cloudflare.WorkersDeployment(
      `${name}WorkersDeployment`,
      {
        accountId: DEFAULT_ACCOUNT_ID,
        scriptName: this._worker.name,
        strategy: "percentage",
        versions: [{ percentage: 100, versionId: this._version.id }],
      },
      { parent: this },
    );

    if (args.domain) {
      const zone = new ZoneLookup(
        `${name}ZoneLookup`,
        {
          accountId: DEFAULT_ACCOUNT_ID,
          domain: args.domain,
        },
        { parent: this },
      );

      this._domain = new cloudflare.WorkersCustomDomain(
        `${name}WorkersCustomDomain`,
        {
          accountId: DEFAULT_ACCOUNT_ID,
          service: this._worker.name,
          hostname: args.domain,
          zoneId: zone.id,
        },
        { parent: this, dependsOn: [this._deployment] },
      );
    }

    this.registerOutputs({
      _hint: this.url,
      _metadata: {
        mode: "deployed",
        path,
        environment,
        url: this.url,
      },
    });
  }

  get url() {
    return this._domain
      ? $interpolate`https://${this._domain.hostname}`
      : this._url.url.apply((url) => (url ? `https://${url}` : url));
  }

  getSSTLink() {
    return {
      properties: {
        url: this.url,
      },
    };
  }
}
